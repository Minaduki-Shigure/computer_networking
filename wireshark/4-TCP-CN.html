<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Wireshark Lab: TCP</title>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        
    </head>
    <body class="vscode-light">
        <h1 id="wireshark-lab-tcp">Wireshark Lab: TCP</h1>
<p>Copyright (c) 2020 Minaduki Shigure.<br>
南京大学 电子科学与工程学院 吴康正 171180571</p>
<h2 id="%e5%ae%9e%e9%aa%8c%e7%8e%af%e5%a2%83">实验环境</h2>
<p>macOS “Mojave” 10.14.5<br>
Broadcom BCM4352 Wireless Network Adapter<br>
Wireshark Version 3.2.2 (v3.2.2-0-ga3efece3d640)</p>
<h2 id="%e5%ae%9e%e9%aa%8c%e5%86%85%e5%ae%b9%e4%bd%a0%e5%a5%bd%e4%b8%96%e7%95%8c">实验内容：你好，世界！</h2>
<ol>
<li>首先运行Wireshark，从原则上来说，不应该允许任何非root用户拥有抓包的权限，因此切换到超级用户，然后再运行程序。<br>
可以看到启动后的界面如下所示：
<img src="file:////Users/minaduki/Desktop/computer_networking/wireshark/pic/1-1.png" alt="Welcome to wireshark"></li>
<li>启动后的界面列出了电脑上可供监听的端口，选择<code>wlp2s0</code>来监听此电脑无线网卡上的所有通讯，可以看见图示中就捕获到了一些不同协议的通讯，比如路由器广播的ARP询问、电脑系统更新时查询服务器DNS的请求等。
<img src="file:////Users/minaduki/Desktop/computer_networking/wireshark/pic/1-2.png" alt="Capture started"></li>
<li>按照课本上的要求，访问网页http://gaia.cs.umass.edu/wireshark-labs/INTRO-wireshark-file1.html，在Wireshark中找到了如下和此次请求有关联的封包：
<img src="file:////Users/minaduki/Desktop/computer_networking/wireshark/pic/1-3.png" alt="Capture result"></li>
<li>可以看见，本地计算机首先向DNS服务器（在本例中配置为路由器）发送了一个DNS请求，得到了网页服务器的IP地址，然后与远程服务器建立了TCP连接，发送HTTP GET请求，远程服务器收到请求后建立TCP连接将HTTP响应发回本地计算机，完成了网页的访问。<br>
另外，可以使用Wireshark的过滤器功能筛选出所有的HTTP请求，列出如下：
<img src="file:////Users/minaduki/Desktop/computer_networking/wireshark/pic/1-4.png" alt="HTTP filter"></li>
<li>按照课本要求，找到本地计算机发出的HTTP GET请求，Wireshark对数据包进行了层次化的结构分析，展开HTTP层的内容，就可以看到具体的GET请求内容。
<img src="file:////Users/minaduki/Desktop/computer_networking/wireshark/pic/1-5.png" alt="HTTP GET"></li>
</ol>
<h2 id="%e5%b0%8f%e7%bb%93">小结</h2>
<p>对于上面获得的HTTP封包，可以看见由于之前已经访问过这个页面，因此此次访问的请求header中包含了“Modified After”的entry，而网页内容的确没有修改，因此收到的响应是“304 Not Modified”，而不是200，服务器也没有回传网页内容，本地浏览器使用了缓存的网页进行显示。</p>
<p>另外发现，在我的计算机上，在启动Wireshark抓包时，有时会完全无法连接网络，询问同学得知，这似乎是Linux上Wireshark的一个普遍Bug，因此在下面的打印请求部分和以后的实验会更换其他平台完成。</p>
<p>对实验要求问题的解答：</p>
<ol>
<li>List 3 protocols: 比如有ARP、DNS、SSL、HTTP、DHCPv6、ICMPv6、TCP、UDP、SMB2等。</li>
<li>How Long: 发送HTTP GET请求的时间戳是1.728137696，接收到返回新消息的时间戳是2.050217356，总共耗时0.32207966秒。</li>
<li>IP: 服务器的IP地址为128.119.245.12，本机地址由于存在NAT的关系，只能看见LAN地址为192.168.3.163.</li>
<li><em>由于要求打印的是OK的响应，而之前实验时没有记录到200 OK，因此这里的请求内容是在更换平台之后重新发出记录的。</em><br>
打印出来的两个请求如下，同时PDF源文件也在同一目录中提供：
<img src="file:////Users/minaduki/Desktop/computer_networking/wireshark/pic/1-6.png" alt="HTTP Requests"></li>
</ol>

    </body>
    </html>