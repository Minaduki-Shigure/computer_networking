<!DOCTYPE html>
<html>
<head>
<title>2_Router_Exercise.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="openflow-tutorial-router-exercise">OpenFlow Tutorial: Router Exercise</h1>
<p>Copyright (c) 2020 Minaduki Shigure.<br>
南京大学 电子科学与工程学院 吴康正 171180571</p>
<h2 id="%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83">实验环境</h2>
<p>macOS &quot;Catalina&quot; 10.15.4<br>
VMware Funsion Pro Version 11.5.3 (15870345)<br>
Ubuntu 14.04.1 trusty w/ x86_64 Linux 4.2.0-27-generic<br>
mininet 2.2.2</p>
<h2 id="%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">实现方式</h2>
<p>基于现有的POX代码加以修改，实现一个控制器，可以控制一个静态路由器完成给定的拓扑网络中的数据转发。</p>
<h2 id="%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B">实验过程</h2>
<h3 id="%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%93%E6%89%91%E8%BF%90%E8%A1%8Cmininet">使用自定义拓扑运行mininet</h3>
<p>由于mininet不能自动生成比较复杂的拓扑，因此使用自定义的文件定义网络拓扑，同时预先配置各个节点的地址、子网和网关。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> mininet.topo <span class="hljs-keyword">import</span> Topo

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTopo</span><span class="hljs-params">( Topo )</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">( self )</span>:</span>
        <span class="hljs-string">"Create custom topo."</span>

        <span class="hljs-comment"># Initialize topology</span>
        Topo.__init__( self )

        <span class="hljs-comment"># Add hosts and switches</span>
        Host_1 = self.addHost( <span class="hljs-string">'h1'</span>, ip=<span class="hljs-string">'10.0.1.100/24'</span>, defaultRoute=<span class="hljs-string">'via 10.0.1.1'</span> )
        Host_2 = self.addHost( <span class="hljs-string">'h2'</span>, ip=<span class="hljs-string">'10.0.2.100/24'</span>, defaultRoute=<span class="hljs-string">'via 10.0.2.1'</span> )
        Host_3 = self.addHost( <span class="hljs-string">'h3'</span>, ip=<span class="hljs-string">'10.0.3.100/24'</span>, defaultRoute=<span class="hljs-string">'via 10.0.3.1'</span> )
        centreSwitch = self.addSwitch( <span class="hljs-string">'s1'</span> )


        <span class="hljs-comment"># Add links</span>
        self.addLink( Host_1, centreSwitch )
        self.addLink( Host_2, centreSwitch )
        self.addLink( Host_3, centreSwitch )


topos = { <span class="hljs-string">'mytopo'</span>: ( <span class="hljs-keyword">lambda</span>: MyTopo() ) }
</div></code></pre>
<p>然后使用自定义的拓扑运行mininet：</p>
<pre class="hljs"><code><div>$ sudo mn --custom mytopo.py --topo mytopo --mac --controller remote
</div></code></pre>
<p>终端输出如下：</p>
<pre class="hljs"><code><div>*** Creating network
*** Adding controller
Unable to contact the remote controller at 127.0.0.1:6653
Connecting to remote controller at 127.0.0.1:6633
*** Adding hosts:
h1 h2 h3 
*** Adding switches:
s1 
*** Adding links:
(h1, s1) (h2, s1) (h3, s1) 
*** Configuring hosts
h1 h2 h3 
*** Starting controller
c0 
*** Starting 1 switches
s1 ...
*** Starting CLI:
</div></code></pre>
<p>mininet成功创建了符合要求的拓扑，对节点输入ifconfig命令，可以看到节点配置正确：</p>
<pre class="hljs"><code><div>mininet&gt; h1 ifconfig
h1-eth0   Link encap:Ethernet  HWaddr 00:00:00:00:00:01  
          inet addr:10.0.1.100  Bcast:10.0.1.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)
</div></code></pre>
<p>这样就完成了本实验mininet的配置。</p>
<h3 id="%E6%8E%A7%E5%88%B6%E5%99%A8%E5%AE%9E%E7%8E%B0">控制器实现</h3>
<p>控制器由POX文件<code>of_router.py</code>实现，该文件在上个实验<code>of_tutorial.py</code>的基础上修改实现。</p>
<p><strong>实际上，实验中的网络是完全静态的，因此本实验可以完全由对接口主机的判断和下发对应的预先准备的流表实现（就像斯坦福提供的solution一样），不过由于是在上一个实验的基础上修改而成的，因此本次实验的代码与solution的思路不同，有一定的学习能力，这样的好处是如果网络拓扑改变，本次实验的代码需要改动的部分会远小于solution需要改动的部分。</strong></p>
<p>由于代码篇幅较长，完整代码请在<a href="https://git.nju.edu.cn/Minaduki/computer_networking/-/tree/master/openflow/src">Git Repo</a>中或者附件中查看。</p>
<p>对于输入的每一个帧，控制器整体的运行逻辑如下：</p>
<ol>
<li>收到包，判断是ARP帧，则转第2步，是IP数据报，则转第5步，否则不予理睬，转第10步。</li>
<li>调用_handle_ARP函数处理。如果是ARP请求，转第3步，如果是ARP回应，转第4步，否则不予理睬，转第10步。</li>
<li>如果请求的地址在ARP缓存中，则回应对应的地址，否则不予理睬。不论判断如何，转第10步。</li>
<li>判断ARP回复的地址是否有在消息队列中等待转发的IP数据报，如果有则发送。不论判断如何，转第10步。</li>
<li>调用_handle_IPv4函数处理。如果是发送给路由器的IP报，转第6步，否则转第7步。</li>
<li>如果是ICMP echo request，调用_reply_ICMP函数回复处理，否则不予理睬。不论判断如何，转第10步。</li>
<li>判断IP报可不可达，如果不可达，返回ICMP unreachable，转第10步，否则转第8步。</li>
<li>查询ARP缓存是否有目标主机的硬件地址，如果没有，将IP报暂存在消息队列，并发送ARP请求，然后转第10步，否则转第9步。</li>
<li>将IP报的硬件地址字段重写并发出，然后下发对应的流表项。转第10步。</li>
<li>处理结束。</li>
</ol>
<p>下面是部分关键代码。</p>
<h4 id="%E6%8E%A7%E5%88%B6%E5%99%A8%E5%AD%98%E5%82%A8">控制器存储</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># ARP cache</span>
self.arp_cache = {}
<span class="hljs-comment"># Init ARP record for router itself.</span>
self.arp_cache[<span class="hljs-string">'10.0.1.1'</span>] = <span class="hljs-string">'FF:FF:FF:FF:FF:01'</span>
self.arp_cache[<span class="hljs-string">'10.0.2.1'</span>] = <span class="hljs-string">'FF:FF:FF:FF:FF:02'</span>
self.arp_cache[<span class="hljs-string">'10.0.3.1'</span>] = <span class="hljs-string">'FF:FF:FF:FF:FF:03'</span>
<span class="hljs-comment"># Default MAC that mininet use for hosts starts from all zeros, </span>
<span class="hljs-comment"># so we start ours from all ones.</span>

<span class="hljs-comment"># Routing table (create a structure with all of the information statically assigned)</span>
self.routing_table = {}
self.routing_table[<span class="hljs-string">'10.0.1.0/24'</span>] = {<span class="hljs-string">'gateway_ip'</span>: <span class="hljs-string">'10.0.1.1'</span>, <span class="hljs-string">'port'</span>: <span class="hljs-number">1</span>}
self.routing_table[<span class="hljs-string">'10.0.2.0/24'</span>] = {<span class="hljs-string">'gateway_ip'</span>: <span class="hljs-string">'10.0.2.1'</span>, <span class="hljs-string">'port'</span>: <span class="hljs-number">2</span>}
self.routing_table[<span class="hljs-string">'10.0.3.0/24'</span>] = {<span class="hljs-string">'gateway_ip'</span>: <span class="hljs-string">'10.0.3.1'</span>, <span class="hljs-string">'port'</span>: <span class="hljs-number">3</span>}

<span class="hljs-comment"># Gateway IP to switch port</span>
self.ip2port_dict = {}
self.ip2port_dict[<span class="hljs-string">'10.0.1.1'</span>] = <span class="hljs-number">1</span>
self.ip2port_dict[<span class="hljs-string">'10.0.2.1'</span>] = <span class="hljs-number">2</span>
self.ip2port_dict[<span class="hljs-string">'10.0.3.1'</span>] = <span class="hljs-number">3</span>

<span class="hljs-comment"># Message queue (while the router waits for an ARP reply)</span>
self.msg_queue = {}
</div></code></pre>
<p>控制器负责维护以下内容：</p>
<ol>
<li>ARP缓存：记录每个IP拥有的硬件地址，初始化时拥有路由器自身的硬件地址信息。</li>
<li>路由表：保存每个子网的网关IP和端口号。</li>
<li>端口表：保存每个子网的网关IP对应的端口号。</li>
<li>消息队列：暂存等待ARP回应的IP报。</li>
</ol>
<p><em>其中，mininet对于主机的硬件地址会从全0开始自动按顺序分配，对于交换机的硬件地址却是随机的（且与控制器ARP缓存预设的不一样），不过这并不会影响实际的网络功能，因此没有进行额外的配置。</em><br>
<em>事实上，我一开始没有意识到主机的硬件地址是从全0开始的，因此我在ARP缓存中给路由器分配的硬件地址也是从全0开始的，直到观察下发流表的debug信息才发现并进行了改正，但是由于本题目中网络拓扑结构的原因，硬件地址冲突并不会影响到网络工作。</em></p>
<h4 id="%E6%B5%81%E8%A1%A8%E4%B8%8B%E5%8F%91">流表下发</h4>
<pre class="hljs"><code><div><span class="hljs-comment"># Install new flow</span>
log.debug(<span class="hljs-string">"Installing flow..."</span>)
log.debug(<span class="hljs-string">"Flow added: MATCH: nw_dst : %s"</span> % dstip)
log.debug(<span class="hljs-string">"Flow added: ACTION: set_src : %s"</span> % self.arp_cache[self.routing_table[dstsubnet][<span class="hljs-string">'gateway_ip'</span>]])
log.debug(<span class="hljs-string">"Flow added: ACTION: set_dst : %s"</span> % self.arp_cache[dstip])
log.debug(<span class="hljs-string">"Flow added: ACTION: output : #%d"</span> % self.ip2port_dict[self.routing_table[dstsubnet][<span class="hljs-string">'gateway_ip'</span>]])

msg = of.ofp_flow_mod()
<span class="hljs-comment">## Set fields to match received packet</span>
msg.match.dl_type = ethernet.IP_TYPE
msg.match.nw_dst = ip_packet.dstip
          
<span class="hljs-comment">#&lt; Set other fields of flow_mod (timeouts? buffer_id?) &gt;</span>
msg.idle_timeout = <span class="hljs-number">60</span>
msg.hard_timeout = <span class="hljs-number">600</span>
msg.flags = <span class="hljs-number">3</span>

<span class="hljs-comment">#&lt; Add an output action, and send -- similar to resend_packet() &gt;</span>
msg.actions.append(of.ofp_action_dl_addr.set_src(self.arp_cache[self.routing_table[dstsubnet][<span class="hljs-string">'gateway_ip'</span>]]))
msg.actions.append(of.ofp_action_dl_addr.set_dst(self.arp_cache[dstip]))
msg.actions.append(of.ofp_action_output(port=self.ip2port_dict[self.routing_table[dstsubnet][<span class="hljs-string">'gateway_ip'</span>]]))

self.connection.send(msg)
log.debug(<span class="hljs-string">"New flow configured."</span>)
</div></code></pre>
<p>在控制器收到的IP报确定可以进行转发后，就会下发一条流表项，流表项会指示路由器将所有符合该目标IP的以太网帧的源硬件地址重写为路由器网关对应的硬件地址，目标硬件地址重写为目标IP对应的硬件地址，然后从对应的接口送出。</p>
<p><em>写报告的时候又意识到，如果在收到ARP reply的时候也加入下发流表的代码，似乎可以提升性能。</em></p>
<h3 id="%E5%8A%9F%E8%83%BD%E9%AA%8C%E8%AF%81">功能验证</h3>
<p>在不同的终端窗口中分别启动POX控制器和mininet：</p>
<pre class="hljs"><code><div>$ ./pox.py log.level --DEBUG misc.of_router
$ sudo mn --custom mytopo.py --topo mytopo --mac --controller remote
</div></code></pre>
<p>首先还是使用h1节点ping节点h2，控制器日志如下：</p>
<pre class="hljs"><code><div>DEBUG:misc.of_router:Controlling [00-00-00-00-00-01 2]
DEBUG:misc.of_router:ARP frame received from port #1
DEBUG:misc.of_router:Updated MAC and port for ip 10.0.1.100 : Port #1, MAC: 00:00:00:00:00:01
DEBUG:misc.of_router:Handling ARP REQUEST frame:
DEBUG:misc.of_router:[ARP REQUEST hw:1 p:2048 00:00:00:00:00:01&gt;00:00:00:00:00:00 10.0.1.100&gt;10.0.1.1]
DEBUG:misc.of_router:Replying that FF:FF:FF:FF:FF:01 has 10.0.1.1
DEBUG:misc.of_router:ARP reply sent to port #1
DEBUG:misc.of_router:IPv4 diagram received from port #1
DEBUG:misc.of_router:IP diagram routable to subnet 10.0.2.0/24
DEBUG:misc.of_router:Trying to forward IP diagram to subnet 10.0.2.0/24 at port 2.
DEBUG:misc.of_router:The owner of 10.0.2.100 unknown. Flooding ARP request to port #2.
DEBUG:misc.of_router:ARP frame received from port #2
DEBUG:misc.of_router:Updated MAC and port for ip 10.0.2.100 : Port #2, MAC: 00:00:00:00:00:02
DEBUG:misc.of_router:Handling ARP REPLY frame:
DEBUG:misc.of_router:[ARP REPLY hw:1 p:2048 00:00:00:00:00:02&gt;ff:ff:ff:ff:ff:02 10.0.2.100&gt;10.0.2.1]
DEBUG:misc.of_router:ARP received: 00:00:00:00:00:02 has 10.0.2.100
DEBUG:misc.of_router:IPv4 diagram received from port #2
DEBUG:misc.of_router:IP diagram routable to subnet 10.0.1.0/24
DEBUG:misc.of_router:Trying to forward IP diagram to subnet 10.0.1.0/24 at port 1.
DEBUG:misc.of_router:IP diagram forwarded to 00:00:00:00:00:01.
DEBUG:misc.of_router:Installing flow...
DEBUG:misc.of_router:Flow added: MATCH: nw_dst : 10.0.1.100
DEBUG:misc.of_router:Flow added: ACTION: set_src : FF:FF:FF:FF:FF:01
DEBUG:misc.of_router:Flow added: ACTION: set_dst : 00:00:00:00:00:01
DEBUG:misc.of_router:Flow added: ACTION: output : #1
DEBUG:misc.of_router:New flow configured.
DEBUG:misc.of_router:IPv4 diagram received from port #1
DEBUG:misc.of_router:IP diagram routable to subnet 10.0.2.0/24
DEBUG:misc.of_router:Trying to forward IP diagram to subnet 10.0.2.0/24 at port 2.
DEBUG:misc.of_router:IP diagram forwarded to 00:00:00:00:00:02.
DEBUG:misc.of_router:Installing flow...
DEBUG:misc.of_router:Flow added: MATCH: nw_dst : 10.0.2.100
DEBUG:misc.of_router:Flow added: ACTION: set_src : FF:FF:FF:FF:FF:02
DEBUG:misc.of_router:Flow added: ACTION: set_dst : 00:00:00:00:00:02
DEBUG:misc.of_router:Flow added: ACTION: output : #2
DEBUG:misc.of_router:New flow configured.
DEBUG:misc.of_router:ARP frame received from port #2
DEBUG:misc.of_router:Handling ARP REQUEST frame:
DEBUG:misc.of_router:[ARP REQUEST hw:1 p:2048 00:00:00:00:00:02&gt;00:00:00:00:00:00 10.0.2.100&gt;10.0.2.1]
DEBUG:misc.of_router:Replying that FF:FF:FF:FF:FF:02 has 10.0.2.1
DEBUG:misc.of_router:ARP reply sent to port #2
</div></code></pre>
<p>日志中包含了整个从源主机发送ARP请求-&gt;路由器回应-&gt;源主机发送IP报给路由器-&gt;路由器发送ARP请求-&gt;路由器转发IP报给目标主机-&gt;控制器下发流表的过程，日志中，参数的配置均正确，同时，mininet终端显示也证明网络连通，可以认为路由器工作正常。</p>
<p>打开h1的终端，ping路由器的IP地址，控制器日志显示如下：</p>
<pre class="hljs"><code><div>DEBUG:misc.of_router:ARP frame received from port #1
DEBUG:misc.of_router:Updated MAC and port for ip 10.0.1.100 : Port #1, MAC: 00:00:00:00:00:01
DEBUG:misc.of_router:Handling ARP REQUEST frame:
DEBUG:misc.of_router:[ARP REQUEST hw:1 p:2048 00:00:00:00:00:01&gt;00:00:00:00:00:00 10.0.1.100&gt;10.0.1.1]
DEBUG:misc.of_router:Replying that FF:FF:FF:FF:FF:01 has 10.0.1.1
DEBUG:misc.of_router:ARP reply sent to port #1
DEBUG:misc.of_router:IPv4 diagram received from port #1
DEBUG:misc.of_router:IP diagram routable to subnet 10.0.1.0/24
DEBUG:misc.of_router:ICMP echo request from 10.0.1.100
DEBUG:misc.of_router:ICMP echo reply sent to 10.0.1.100
DEBUG:misc.of_router:IPv4 diagram received from port #1
DEBUG:misc.of_router:IP diagram routable to subnet 10.0.1.0/24
DEBUG:misc.of_router:ICMP echo request from 10.0.1.100
DEBUG:misc.of_router:ICMP echo reply sent to 10.0.1.100
(省略)
</div></code></pre>
<p>同时h1终端显示ping的回应正常：</p>
<p><img src="./pic/2-1.png" alt="h1 @ h1 ping s1"></p>
<p><em>理论而言，如何回应ICMP也可以作为流表项下发，不过因为不是常用的功能，对整体性能影响不大，因此没有实装。</em></p>
<p>然后，使用h1节点ping不存在的10.99.0.1，控制器日志如下：</p>
<pre class="hljs"><code><div>DEBUG:misc.of_router:IPv4 diagram received from port #1
DEBUG:misc.of_router:Destination 10.99.0.1 is unreachable. Replying with ICMP Unreachable.
</div></code></pre>
<p>同时h1接收到了返回的ICMP不可达的包：</p>
<p><img src="./pic/2-2.png" alt="h1 @ h1 ping unreachable"></p>
<p>最后，使用pingall命令进行整体测试：</p>
<pre class="hljs"><code><div>*** Ping: testing ping reachability
h1 -&gt; h2 h3 
h2 -&gt; h1 h3 
h3 -&gt; h1 h2 
*** Results: 0% dropped (6/6 received)
</div></code></pre>
<p>网络连通，工作正常。</p>
<p>使用iperf命令测试网络性能：</p>
<pre class="hljs"><code><div>*** Iperf: testing TCP bandwidth between h1 and h3 
*** Results: ['26.1 Gbits/sec', '26.0 Gbits/sec']
</div></code></pre>
<p>网络性能符合预期，工作正常。</p>
<h2 id="%E5%B0%8F%E7%BB%93">小结</h2>
<p>通过此次实验，详细地理解了路由器的工作方式，加深了对OpenFlow流表的概念，同时对IP与以太网的工作方式有了初步的掌握。</p>
<h2 id="%E9%99%84%E5%BD%95%E5%AE%8C%E6%95%B4%E6%BA%90%E7%A0%81">附录：完整源码</h2>
<pre class="hljs"><code><div><span class="hljs-comment"># Copyright 2012 James McCauley</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># Licensed under the Apache License, Version 2.0 (the "License");</span>
<span class="hljs-comment"># you may not use this file except in compliance with the License.</span>
<span class="hljs-comment"># You may obtain a copy of the License at:</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># Unless required by applicable law or agreed to in writing, software</span>
<span class="hljs-comment"># distributed under the License is distributed on an "AS IS" BASIS,</span>
<span class="hljs-comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="hljs-comment"># See the License for the specific language governing permissions and</span>
<span class="hljs-comment"># limitations under the License.</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># Modefied by Minaduki Shigure @ NJU, June 2020.</span>
<span class="hljs-comment"># Running the switch as a static router.</span>
<span class="hljs-comment">#</span>

<span class="hljs-string">"""
This component is for use with the OpenFlow tutorial.

It acts as a simple hub, but can be modified to act like an L2
learning switch.

It's roughly similar to the one Brandon Heller did for NOX.
"""</span>

<span class="hljs-keyword">from</span> pox.core <span class="hljs-keyword">import</span> core
<span class="hljs-keyword">import</span> pox.openflow.libopenflow_01 <span class="hljs-keyword">as</span> of
<span class="hljs-keyword">from</span> netaddr <span class="hljs-keyword">import</span> *
<span class="hljs-keyword">from</span> pox.lib.revent <span class="hljs-keyword">import</span> *
<span class="hljs-keyword">from</span> pox.lib.packet.ethernet <span class="hljs-keyword">import</span> ethernet
<span class="hljs-keyword">from</span> pox.lib.packet.ipv4 <span class="hljs-keyword">import</span> ipv4
<span class="hljs-keyword">from</span> pox.lib.packet.arp <span class="hljs-keyword">import</span> arp
<span class="hljs-keyword">from</span> pox.lib.packet.icmp <span class="hljs-keyword">import</span> icmp, echo
<span class="hljs-keyword">from</span> pox.lib.packet.icmp <span class="hljs-keyword">import</span> TYPE_ECHO_REQUEST, TYPE_ECHO_REPLY, TYPE_DEST_UNREACH, CODE_UNREACH_NET, CODE_UNREACH_HOST
<span class="hljs-keyword">from</span> pox.lib.addresses <span class="hljs-keyword">import</span> IPAddr, EthAddr
<span class="hljs-keyword">from</span> pox.lib.util <span class="hljs-keyword">import</span> str_to_bool, dpid_to_str


log = core.getLogger()



<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Router</span> <span class="hljs-params">(object)</span>:</span>
  <span class="hljs-string">"""
  A Router object is created for each switch that connects.
  A Connection object for that switch is passed to the __init__ function.
  """</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span> <span class="hljs-params">(self, connection)</span>:</span>
    <span class="hljs-comment"># Keep track of the connection to the switch so that we can</span>
    <span class="hljs-comment"># send it messages!</span>
    self.connection = connection

    <span class="hljs-comment"># This binds our PacketIn event listener</span>
    connection.addListeners(self)

    <span class="hljs-comment"># Use this table to keep track of which ethernet address is on</span>
    <span class="hljs-comment"># which switch port (keys are MACs, values are ports).</span>
    <span class="hljs-comment"># self.mac_to_port = {}</span>

    <span class="hljs-comment"># ARP cache</span>
    self.arp_cache = {}
    <span class="hljs-comment"># Init ARP record for router itself.</span>
    self.arp_cache[<span class="hljs-string">'10.0.1.1'</span>] = <span class="hljs-string">'FF:FF:FF:FF:FF:01'</span>
    self.arp_cache[<span class="hljs-string">'10.0.2.1'</span>] = <span class="hljs-string">'FF:FF:FF:FF:FF:02'</span>
    self.arp_cache[<span class="hljs-string">'10.0.3.1'</span>] = <span class="hljs-string">'FF:FF:FF:FF:FF:03'</span>
    <span class="hljs-comment"># Default MAC that mininet use starts from all zeros, </span>
    <span class="hljs-comment"># so we start ours from all ones.</span>

    <span class="hljs-comment"># Routing table (create a structure with all of the information statically assigned)</span>
    self.routing_table = {}
    self.routing_table[<span class="hljs-string">'10.0.1.0/24'</span>] = {<span class="hljs-string">'gateway_ip'</span>: <span class="hljs-string">'10.0.1.1'</span>, <span class="hljs-string">'port'</span>: <span class="hljs-number">1</span>}
    self.routing_table[<span class="hljs-string">'10.0.2.0/24'</span>] = {<span class="hljs-string">'gateway_ip'</span>: <span class="hljs-string">'10.0.2.1'</span>, <span class="hljs-string">'port'</span>: <span class="hljs-number">2</span>}
    self.routing_table[<span class="hljs-string">'10.0.3.0/24'</span>] = {<span class="hljs-string">'gateway_ip'</span>: <span class="hljs-string">'10.0.3.1'</span>, <span class="hljs-string">'port'</span>: <span class="hljs-number">3</span>}

    <span class="hljs-comment"># Gateway IP to switch port</span>
    self.ip2port_dict = {}
    self.ip2port_dict[<span class="hljs-string">'10.0.1.1'</span>] = <span class="hljs-number">1</span>
    self.ip2port_dict[<span class="hljs-string">'10.0.2.1'</span>] = <span class="hljs-number">2</span>
    self.ip2port_dict[<span class="hljs-string">'10.0.3.1'</span>] = <span class="hljs-number">3</span>

    <span class="hljs-comment"># Message queue (while the router waits for an ARP reply)</span>
    self.msg_queue = {}


  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">resend_packet</span> <span class="hljs-params">(self, packet_in, out_port)</span>:</span>
    <span class="hljs-string">"""
    Instructs the switch to resend a packet that it had sent to us.
    "packet_in" is the ofp_packet_in object the switch had sent to the
    controller due to a table-miss.
    """</span>
    msg = of.ofp_packet_out()
    msg.data = packet_in

    <span class="hljs-comment"># Add an action to send to the specified port</span>
    action = of.ofp_action_output(port = out_port)
    msg.actions.append(action)

    <span class="hljs-comment"># Send message to switch</span>
    self.connection.send(msg)


  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_handle_ARP</span> <span class="hljs-params">(self, packet, packet_in)</span>:</span>
    <span class="hljs-string">"""
    Handles ARP frame.
    """</span>
    <span class="hljs-comment"># Read ARP info.</span>
    arp_body = packet.payload
    hwdst = arp_body.hwdst
    hwsrc = arp_body.hwsrc
    protodst = arp_body.protodst
    protosrc = arp_body.protosrc
    opcode = arp_body.opcode

    <span class="hljs-comment"># The type of variables need to be converted.</span>
    hwdst = str(hwdst)
    hwsrc = str(hwsrc)
    protodst = str(protodst)
    protosrc = str(protosrc)

    <span class="hljs-comment"># New host here</span>
    <span class="hljs-keyword">if</span> protosrc <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.arp_cache.keys():
      self.arp_cache[protosrc] = hwsrc
      <span class="hljs-comment"># print(self.arp_cache)</span>
      self.ip2port_dict[protosrc] = packet_in.in_port
      log.debug(<span class="hljs-string">"Updated MAC and port for ip %s : Port #%d, MAC: %s"</span> % (protosrc, packet_in.in_port, hwsrc))
      <span class="hljs-keyword">for</span> subnet <span class="hljs-keyword">in</span> self.routing_table.keys():
        <span class="hljs-keyword">if</span> IPAddress(protodst) <span class="hljs-keyword">in</span> IPNetwork(subnet):
          myhwaddr = self.arp_cache[self.routing_table[subnet][<span class="hljs-string">'gateway_ip'</span>]]
          <span class="hljs-keyword">break</span>;
      
    <span class="hljs-keyword">if</span> opcode == arp.REQUEST:
      log.debug(<span class="hljs-string">"Handling ARP REQUEST frame:"</span>)
      log.debug(arp_body._to_str())

      <span class="hljs-keyword">if</span> protodst <span class="hljs-keyword">in</span> self.arp_cache.keys():
        log.debug(<span class="hljs-string">"Replying that %s has %s"</span> % (self.arp_cache[protodst], protodst))
        arp_reply = arp()
        arp_reply.opcode = arp.REPLY
        arp_reply.hwsrc = EthAddr(self.arp_cache[protodst])
        arp_reply.hwdst = arp_body.hwsrc
        arp_reply.protosrc = arp_body.protodst
        arp_reply.protodst = arp_body.protosrc

        ether = ethernet()
        ether.type = ether.ARP_TYPE
        ether.src = EthAddr(self.arp_cache[protodst])
        ether.dst = arp_body.hwsrc
        ether.payload = arp_reply

        self.resend_packet(ether, packet_in.in_port)
        log.debug(<span class="hljs-string">"ARP reply sent to port #%d"</span> % packet_in.in_port)

    <span class="hljs-keyword">elif</span> opcode == arp.REPLY:
      log.debug(<span class="hljs-string">"Handling ARP REPLY frame:"</span>)
      log.debug(arp_body._to_str())

      <span class="hljs-keyword">if</span> protosrc <span class="hljs-keyword">in</span> self.msg_queue.keys():
        log.debug(<span class="hljs-string">"ARP received: %s has %s"</span> % (hwsrc, protosrc))
        
        ether = ethernet()
        ether.type = ether.IP_TYPE
        ether.src = EthAddr(self.arp_cache[self.routing_table[self.msg_queue[protosrc][<span class="hljs-string">'dstsubnet'</span>]][<span class="hljs-string">'gateway_ip'</span>]])
        ether.dst = EthAddr(hwsrc)
        ether.payload = self.msg_queue[protosrc][<span class="hljs-string">'ip_packet'</span>]
        self.resend_packet(ether, packet_in.in_port)
        self.msg_queue.pop(protosrc)

    <span class="hljs-keyword">else</span>:
      log.warning(<span class="hljs-string">"Unsupported ARP opcode %d. Ignored."</span> % opcode)


  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_reply_ICMP</span> <span class="hljs-params">(self, packet, packet_in)</span>:</span>
    <span class="hljs-string">"""
    Replys ICMP packet.
    """</span>
    ip_packet = packet.payload
    icmp_body = ip_packet.payload
    <span class="hljs-comment"># log.debug()</span>

    <span class="hljs-keyword">if</span> icmp_body.type == TYPE_ECHO_REQUEST:
      log.debug(<span class="hljs-string">"ICMP echo request from %s"</span> % str(ip_packet.srcip))
      icmp_reply = icmp_body
      icmp_reply.type = TYPE_ECHO_REPLY

      ip_reply = ipv4()
      ip_reply.protocol = ipv4.ICMP_PROTOCOL
      ip_reply.srcip = ip_packet.dstip
      ip_reply.dstip = ip_packet.srcip
      ip_reply.payload = icmp_reply

      ether = ethernet()
      ether.type = ethernet.IP_TYPE
      ether.src = packet.dst
      ether.dst = packet.src
      ether.payload = ip_reply

      self.resend_packet(ether, packet_in.in_port)
      log.debug(<span class="hljs-string">"ICMP echo reply sent to %s"</span> % ip_reply.dstip)

    <span class="hljs-keyword">else</span>:
      log.warning(<span class="hljs-string">"I am not supposed to reply to ICMP type %d. Dropping."</span> % icmp_body.type)
      

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_handle_IPv4</span> <span class="hljs-params">(self, packet, packet_in)</span>:</span>
    <span class="hljs-string">"""
    Handles IPv4 diagram.
    """</span>

    ip_packet = packet.payload <span class="hljs-comment"># This is the packet payload.</span>

    srcip = ip_packet.srcip
    dstip = ip_packet.dstip
    srcip = str(srcip)
    dstip = str(dstip)
    is_routable = <span class="hljs-literal">False</span>

    <span class="hljs-keyword">for</span> subnet <span class="hljs-keyword">in</span> self.routing_table:
      <span class="hljs-keyword">if</span> IPAddress(dstip) <span class="hljs-keyword">in</span> IPNetwork(subnet):
        is_routable = <span class="hljs-literal">True</span>
        dstsubnet = subnet
        log.debug(<span class="hljs-string">"IP diagram routable to subnet %s"</span> % dstsubnet)
        <span class="hljs-keyword">break</span>

    <span class="hljs-keyword">if</span> is_routable:
      <span class="hljs-keyword">if</span> self.routing_table[dstsubnet][<span class="hljs-string">'gateway_ip'</span>] == dstip:
        <span class="hljs-keyword">if</span> ip_packet.protocol == ipv4.ICMP_PROTOCOL:
          self._reply_ICMP(packet, packet_in)
        <span class="hljs-keyword">else</span>:
          log.warning(<span class="hljs-string">"I am not supposed to reply to any IP diagrams. Dropping."</span>)
      <span class="hljs-keyword">else</span>:
        out_port = self.ip2port_dict[self.routing_table[dstsubnet][<span class="hljs-string">'gateway_ip'</span>]]
        log.debug(<span class="hljs-string">"Trying to forward IP diagram to subnet %s at port %d."</span> % (dstsubnet, out_port))
        <span class="hljs-keyword">if</span> dstip <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.arp_cache.keys():
          self.msg_queue[dstip] = {<span class="hljs-string">'dstsubnet'</span>: dstsubnet, <span class="hljs-string">'ip_packet'</span>: ip_packet}
          log.debug(<span class="hljs-string">"The owner of %s unknown. Flooding ARP request to port #%d."</span> % (dstip, out_port))

          arp_body = arp()
          arp_body.opcode = arp.REQUEST
          arp_body.protosrc = IPAddr(self.routing_table[dstsubnet][<span class="hljs-string">'gateway_ip'</span>])
          arp_body.protodst = ip_packet.dstip
          arp_body.hwsrc = EthAddr(self.arp_cache[self.routing_table[dstsubnet][<span class="hljs-string">'gateway_ip'</span>]])
          arp_body.hwdst = EthAddr(<span class="hljs-string">'FF:FF:FF:FF:FF:FF'</span>)

          ether = ethernet()
          ether.type = ethernet.ARP_TYPE
          ether.src = EthAddr(self.arp_cache[self.routing_table[dstsubnet][<span class="hljs-string">'gateway_ip'</span>]])
          ether.dst = EthAddr(<span class="hljs-string">'FF:FF:FF:FF:FF:FF'</span>)
          ether.payload = arp_body

          self.resend_packet(ether, out_port)

        <span class="hljs-keyword">else</span>:
          fwd = packet
          fwd.src = EthAddr(self.arp_cache[self.routing_table[dstsubnet][<span class="hljs-string">'gateway_ip'</span>]])
          fwd.dst = EthAddr(self.arp_cache[dstip])
          self.resend_packet(fwd, out_port)
          log.debug(<span class="hljs-string">"IP diagram forwarded to %s."</span> % fwd.dst)

          <span class="hljs-comment"># Install new flow</span>
          log.debug(<span class="hljs-string">"Installing flow..."</span>)
          log.debug(<span class="hljs-string">"Flow added: MATCH: nw_dst : %s"</span> % dstip)
          log.debug(<span class="hljs-string">"Flow added: ACTION: set_src : %s"</span> % self.arp_cache[self.routing_table[dstsubnet][<span class="hljs-string">'gateway_ip'</span>]])
          log.debug(<span class="hljs-string">"Flow added: ACTION: set_dst : %s"</span> % self.arp_cache[dstip])
          log.debug(<span class="hljs-string">"Flow added: ACTION: output : #%d"</span> % self.ip2port_dict[self.routing_table[dstsubnet][<span class="hljs-string">'gateway_ip'</span>]])

          msg = of.ofp_flow_mod()
          <span class="hljs-comment">## Set fields to match received packet</span>
          msg.match.dl_type = ethernet.IP_TYPE
          msg.match.nw_dst = ip_packet.dstip
          
          <span class="hljs-comment">#&lt; Set other fields of flow_mod (timeouts? buffer_id?) &gt;</span>
          msg.idle_timeout = <span class="hljs-number">60</span>
          msg.hard_timeout = <span class="hljs-number">600</span>
          msg.flags = <span class="hljs-number">3</span>

          <span class="hljs-comment">#&lt; Add an output action, and send -- similar to resend_packet() &gt;</span>
          msg.actions.append(of.ofp_action_dl_addr.set_src(self.arp_cache[self.routing_table[dstsubnet][<span class="hljs-string">'gateway_ip'</span>]]))
          msg.actions.append(of.ofp_action_dl_addr.set_dst(self.arp_cache[dstip]))
          msg.actions.append(of.ofp_action_output(port=self.ip2port_dict[self.routing_table[dstsubnet][<span class="hljs-string">'gateway_ip'</span>]]))

          self.connection.send(msg)
          log.debug(<span class="hljs-string">"New flow configured."</span>)

    <span class="hljs-keyword">else</span>:
      log.debug(<span class="hljs-string">"Destination %s is unreachable. Replying with ICMP Unreachable."</span> % dstip)
      
      <span class="hljs-keyword">for</span> subnet <span class="hljs-keyword">in</span> self.routing_table:
        <span class="hljs-keyword">if</span> IPAddress(srcip) <span class="hljs-keyword">in</span> IPNetwork(subnet):
          srcsubnet = subnet
          <span class="hljs-keyword">break</span>

      icmp_reply = icmp()
      icmp_reply.type = TYPE_DEST_UNREACH
      icmp_reply.code = CODE_UNREACH_NET
      icmp_reply.payload = ip_packet.payload.payload

      ip_reply = ipv4()
      ip_reply.protocol = ipv4.ICMP_PROTOCOL
      ip_reply.srcip = IPAddr(self.routing_table[srcsubnet][<span class="hljs-string">'gateway_ip'</span>])
      ip_reply.dstip = ip_packet.srcip
      ip_reply.payload = icmp_reply

      ether = ethernet()
      ether.type = ethernet.IP_TYPE
      ether.src = packet.dst
      ether.dst = packet.src
      ether.payload = ip_reply

      self.resend_packet(ether, packet_in.in_port)


  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">act_like_router</span> <span class="hljs-params">(self, packet, packet_in)</span>:</span>
    <span class="hljs-string">"""
    Implement router-like behavior.
    """</span>

    <span class="hljs-comment"># Learn the port for the source MAC</span>
    <span class="hljs-comment"># self.mac_to_port[packet.src] = packet_in.in_port</span>
    <span class="hljs-comment"># log.debug("Updated MAC for port %d : %s" % (packet_in.in_port, packet.src))</span>

    <span class="hljs-keyword">if</span> packet.type == ethernet.ARP_TYPE:
      log.debug(<span class="hljs-string">"ARP frame received from port #%d"</span> % packet_in.in_port)
      self._handle_ARP(packet, packet_in)
    <span class="hljs-keyword">elif</span> packet.type == ethernet.IP_TYPE:
      log.debug(<span class="hljs-string">"IPv4 diagram received from port #%d"</span> % packet_in.in_port)
      self._handle_IPv4(packet, packet_in)
    <span class="hljs-keyword">else</span>:
      log.warning(<span class="hljs-string">"Unsupported frame received from port #%d. Dropping."</span> % packet_in.in_port)


  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_handle_PacketIn</span> <span class="hljs-params">(self, event)</span>:</span>
    <span class="hljs-string">"""
    Handles packet in messages from the switch.
    """</span>
    packet = event.parsed <span class="hljs-comment"># This is the parsed packet data.</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> packet.parsed:
      log.warning(<span class="hljs-string">"Ignoring incomplete packet"</span>)
      <span class="hljs-keyword">return</span>

    packet_in = event.ofp <span class="hljs-comment"># The actual ofp_packet_in message.</span>

    <span class="hljs-comment"># Comment out the following line and uncomment the one after</span>
    <span class="hljs-comment"># when starting the exercise.</span>
    self.act_like_router(packet, packet_in)



<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">launch</span> <span class="hljs-params">()</span>:</span>
  <span class="hljs-string">"""
  Starts the component
  """</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start_switch</span> <span class="hljs-params">(event)</span>:</span>
    log.debug(<span class="hljs-string">"Controlling %s"</span> % (event.connection,))
    Router(event.connection)
  core.openflow.addListenerByName(<span class="hljs-string">"ConnectionUp"</span>, start_switch)
</div></code></pre>

</body>
</html>
